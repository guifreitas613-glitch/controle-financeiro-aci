import { db } from "./firebase";
import { 
  collection, 
  addDoc, 
  getDocs, 
  query, 
  orderBy, 
  doc, 
  updateDoc, 
  deleteDoc,
  serverTimestamp,
  where,
  QuerySnapshot,
  DocumentData,
  Timestamp
} from "firebase/firestore";
import { Transaction, ImportedRevenue } from './types';

// Omit 'id' as it will be generated by Firestore
type TransactionData = Omit<Transaction, 'id'>;
type ImportedRevenueData = Omit<ImportedRevenue, 'id'>;

// --- Transações Manuais ---

// Salvar transação manual
export function saveTransaction(data: TransactionData, userId: string) {
  const transactionsCol = collection(db, "transacoes");
  return addDoc(transactionsCol, {
    ...data,
    tipoInterno: 'transacao',
    criadoPor: userId, // Mantido apenas para fins de auditoria
    criadoEm: serverTimestamp()
  });
}

// Ler transações manuais (carregamento global para todos os usuários)
export function getTransactions() {
  const transactionsCol = collection(db, "transacoes");
  const q = query(
    transactionsCol,
    where("tipoInterno", "==", "transacao"),
    orderBy("date", "desc")
  );
  return getDocs(q);
}

// Atualizar transação (coleção transacoes)
export function updateTransaction(id: string, data: Partial<TransactionData>) {
    const transactionDoc = doc(db, "transacoes", id);
    return updateDoc(transactionDoc, data);
}

// Deletar transação (coleção transacoes)
export function deleteTransaction(id: string) {
    const transactionDoc = doc(db, "transacoes", id);
    return deleteDoc(transactionDoc);
}

// --- Receitas Importadas (na coleção transacoes) ---

// Helper para gerar ID único determinístico
function generateRevenueId(data: ImportedRevenueData): string {
    const raw = [
        data.date,
        data.conta,
        data.cliente,
        data.codAssessor,
        data.assessorPrincipal,
        data.classificacao,
        data.ativo,
        data.tipoReceita,
        data.receitaLiquidaEQI
    ].join('|');

    let hash = 0;
    for (let i = 0; i < raw.length; i++) {
        const char = raw.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return `rev_${Math.abs(hash).toString(16)}_${raw.length}`;
}

// Salvar receita importada em 'transacoes' (verificação de duplicidade global)
export async function saveImportedRevenue(data: ImportedRevenueData, userId: string) {
    const transactionsCol = collection(db, "transacoes");
    const idUnico = generateRevenueId(data);

    // Verificar duplicidade global dentro de transacoes
    const q = query(
        transactionsCol, 
        where("tipoInterno", "==", "receita_importada"),
        where('idUnico', '==', idUnico)
    );
    const existingDocs = await getDocs(q);

    if (!existingDocs.empty) {
        throw new Error("Duplicata detectada");
    }

    return addDoc(transactionsCol, {
        ...data,
        idUnico,
        tipoInterno: 'receita_importada',
        criadoPor: userId,
        criadoEm: serverTimestamp()
    });
}

// Ler apenas receitas importadas de 'transacoes' (global)
export function getImportedRevenues() {
    const transactionsCol = collection(db, "transacoes");
    const q = query(
        transactionsCol, 
        where("tipoInterno", "==", "receita_importada"),
        orderBy("date", "desc")
    );
    return getDocs(q);
}

// Deletar receita importada (pelo ID em transacoes)
export function deleteImportedRevenue(id: string) {
    const docRef = doc(db, "transacoes", id);
    return deleteDoc(docRef);
}

// Buscar receitas por período em 'transacoes' (global)
export function getRevenuesByPeriod(startDateIso: string, endDateIso: string) {
    const transactionsCol = collection(db, "transacoes");
    const q = query(
        transactionsCol,
        where("tipoInterno", "==", "receita_importada"),
        where("date", ">=", startDateIso),
        where("date", "<=", endDateIso)
    );
    return getDocs(q);
}

// Rotina de Deduplicação e Limpeza na coleção 'transacoes' (global)
export async function deduplicateImportedRevenues() {
    const transactionsCol = collection(db, "transacoes");
    
    // Busca apenas receitas importadas
    const q = query(
        transactionsCol, 
        where("tipoInterno", "==", "receita_importada")
    );
    const snapshot = await getDocs(q);

    const processedIds = new Set<string>();
    let deletedCount = 0;
    let updatedCount = 0;

    const getTime = (docData: DocumentData) => {
        if (docData.criadoEm && typeof (docData.criadoEm as any).toMillis === 'function') {
            return (docData.criadoEm as Timestamp).toMillis();
        }
        return new Date(docData.date).getTime();
    };

    const docs = snapshot.docs.sort((a, b) => {
        const timeA = getTime(a.data());
        const timeB = getTime(b.data());
        return timeA - timeB;
    });

    for (const docSnapshot of docs) {
        const data = docSnapshot.data() as ImportedRevenueData & { idUnico?: string };
        let idUnico = data.idUnico;

        if (!idUnico) {
            idUnico = generateRevenueId(data);
            await updateDoc(docSnapshot.ref, { idUnico });
            updatedCount++;
        }

        if (processedIds.has(idUnico)) {
            await deleteDoc(docSnapshot.ref);
            deletedCount++;
        } else {
            processedIds.add(idUnico);
        }
    }

    return { updatedCount, deletedCount };
}